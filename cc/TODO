・コメント => リードマクロを導入すればライブラリレベルで実装可能
・リードマクロ
・internしないシンボル
・interfaceや型クラス的な仕組み
  => 要はできるだけ汎用的なライブラリを(効率良く)書ける仕組みが欲しい
・モジュールシステム(階層的なパッケージ)
・パターンマッチ
　・emumクラス的なもの？
・interfaceを必ずしもオブジェクトと関連付ける必要はなく、
　関数セットクラスのようなものにまとめて、引数に渡せるようにしても良い。
　=> こちらの方が応用性は高いし、実装も楽そう
・型推論
・リファレンス型: Cのポインタに近い

(def-interface (comparable (:prefix cmp)) ; or def-hoge-class
 (< :type (function (t t) boolean))
 (= :type (function (t t) boolean)))

(implement (for-num comparable)
  (< (a b)
    (declare (fixum a b))
    (< a b))
  (= (a b)
    (declare (fixnum a b))
    (= a b)))

(register fixnum (for-num comparable)) ; default interface for specific type

(defun sort (list &key cmp)
  (declare (comparable cmp))
  (destructuring-bind (x . list) list
    (append 
     (sort (filter (lambda (y) ((cmp <) y x)) list) :cmp cmp)
     (list x)
     (sort (filter (lambda (y) ((cmp >=) y x)) list) :cmp cmp))))

;;-----------------------------
;; パターンマッチング用の記号を一個用意するか・・・・
;; ?(maybe ...) => ((maybe match) ...)   ; match は型クラス？ => 制約はどう表現する(全部のパターンを網羅しているかどうか)
(case (fn aaa)
  (?(maybe none) 'none)
  (?(maybe (some ?(list))) 'empty)
  (?(maybe (some ?(list x . xs))) 'rest))

;;-----------------------------
;; モジュールシステム
・親パッケージ指定
・スコープがパッケージ内のみのnickname付与

;;-----------------------------
;; 並列処理 ...

;;-----------------------------
;; 副作用 ...
